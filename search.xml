<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[math_and_physics]]></title>
    <url>%2F2020%2F02%2F26%2Fmath-and-physics%2F</url>
    <content type="text"><![CDATA[1 数学演进历史 2 数学的用处]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学演变</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sonarqube-study]]></title>
    <url>%2F2020%2F02%2F25%2Fsonarqube-study%2F</url>
    <content type="text"><![CDATA[1 sonarqube介绍SonarQube 官网 2 sonarqube插件介绍3 sonarqube实例3.1 使用数据库4 sonarqube二次开发5 sonarqube原理介绍]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>代码质量度量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rocket]]></title>
    <url>%2F2019%2F12%2F28%2Frocket%2F</url>
    <content type="text"><![CDATA[1 火箭-胖五的介绍 908天的等待之后，我国新一代大型运载火箭——长征五号迎来第三次发射任务。12月27日20时45分，中国文昌航天发射场，长征五号遥三火箭带着耀眼的光芒，撼天动地，冲破云霄。这次发射任务的成功，意味着我国具备了探索更远深空的能力，也为未来实现探月工程三期、首次火星探测任务等国家重大科技专项和重大工程奠定了重要基础，迈出了建设航天强国的坚实步伐。 遥三火箭有哪些特点？ 200余项技术改进，代表我国运载火箭科技创新最高水平 作为我国首型5米芯级直径的大推力运载火箭，长征五号运载火箭因为体型宽大，被亲切地称为“胖五”火箭。 长征五号是我国首个自主研制的新一代大型运载火箭，创下了多个“第一”与“之最”，代表了我国运载火箭科技创新的最高水平。长征家族中，长征五号可谓是名符其实的“大火箭”——起飞质量最大、起飞推力最大、箭体结构最大、运载能力最强、运载效率最高。与国际同类现役运载火箭相比，长征五号近地轨道25吨左右的运载能力，已位居世界前列。长征五号还填补了我国大推力无毒无污染液体火箭发动机的空白，赋予中国运载火箭“绿色环保大推力”的新名片。 大国重器，十年“磨箭”。2016年11月3日，经过10余年的工程研制，长征五号火箭精彩亮相，首飞成功。然而，在2017年7月2日实施的第二次发射任务中，长征五号遥二火箭却因为发动机局部结构问题未能将卫星送入预定轨道。从第二次的发射失利到第三次的圆满成功，一共历时908天。在这30个月里，长五研制团队经历了什么？大火箭又作了哪些技术改进？ “归零”，成为记者采访过程中最常听到的词语。这是中国航天从实践中总结提出的解决质量问题的方法。中国航天科技集团一院长征五号火箭总指挥王珏告诉记者，“经过两年多的归零和验证工作，研制团队攻克了发动机技术难关。并且在完成发动机问题归零的同时，长五火箭的技术改进和可靠性提升工作也实现了突破。” 长征五号遥二火箭失利后，经过100余天的故障排查与定位以及180余天的试验验证，失利原因终于确认。火箭芯一级氢氧发动机在复杂力热环境下，局部结构发生异常，发动机推力瞬时大幅下降，致使发射任务失利。 “火箭上次失败，是一个复杂力热环境的相互共同作用下，使发动机的某一个零部件组件不能适应，出现失效。但这个毛病隐藏得比较深，偶尔出现，大多数情况下不出现，一旦出现就是灾难性的。所以这次归零，我们通过地面反反复复的各方面理论分析、试验验证，终于把‘捣蛋’的这个‘家伙’逮住了。” 中国航天科技集团一院长征系列火箭总设计师龙乐豪院士说。回忆起遥二发射失利后的场景，满头白发的龙乐豪说，当时并未与研制团队过多交流，“我相信他们有能力顶住压力。” 长五人确实顶住了压力，尽管攻关的过程并非一帆风顺。中国航天科技集团一院长征五号火箭总设计师李东对几个时间节点印象深刻。2018年11月30日，改进后的芯一级氢氧发动机在长程试车过程中出现问题，经过改进，2019年2月顺利通过了两次长程试车验证。然而到了2019年4月4日，在长征五号遥三火箭的总装工作进入到最后阶段时，一台用于后续任务的芯一级氢氧发动机又发现了问题…… 面对一个又一个困难，科研人员没有灰心，会议室忘却寒暑、试验场不分昼夜。908天的夜以继日，集聚全国优势资源联合攻关，累计40余次15000余秒关键技术试验，终于攻破一个又一个难关。不只是发动机研制团队，各参研参试单位的科研人员、工程技术人员，联合攻关的院士专家，发射场系统的工作人员，甚至包括航天人的家属……都为长五遥三的成功付出了艰辛的努力。 据介绍，遥三火箭在遥二火箭的基础上，进行了200余项技术改进。其中比较重大的技术改进有9项，包括了发动机设计改进、长排整流罩设计改进、利用系统调节方案改进等。 大块头能做啥？ 肩负月球采样返回、火星探测等重要任务 运载火箭的能力有多大，中国航天的舞台就有多大。作为目前我国运载能力最大的火箭，“胖五”是承载着中华民族对浩瀚宇宙向往的“梦想之箭”，也是我国由航天大国迈向航天强国的重要标志。长征五号肩负着月球采样返回、火星探测等多项重大航天工程任务，也可用于不同地球轨道大型载荷及其他深空探测任务载荷的发射。 再登月球——2020年，我国将用长征五号运载火箭择机发射“嫦娥五号”，实现月面无人采样返回，圆满完成探月工程三步走的规划目标。嫦娥五号任务需要将嫦娥五号探测器直接送入地月转移轨道，这必须由具有大运载能力的长征五号运载火箭来完成。 首探火星——目前，我国正在开展首次火星探测工程的研制工作。按照计划，2020年，我国将通过长征五号发射火星探测器，并通过一次发射实现火星环绕、着陆和巡视探测。李东介绍，长征五号的成功研制，将大幅度提高我国进入空间的能力，助力我国深空探测能力和水平的提升，实现在深空探测领域的跨越。 此外，长征五号火箭还为构筑我国新一代运载火箭系列型谱奠定了坚实技术基础。2020年，长征五号B等多型新一代运载火箭将相继迎来首飞。 火箭上“运”了啥？ 搭载我国最重同步轨道卫星，全面验证“东方红五号卫星平台”关键技术 很多人还很好奇，长五遥三火箭发射，搭载的是什么卫星？ 专家介绍，长征五号遥三火箭上的这名“乘客”，就是实践二十号卫星。它是以“东方红五号卫星平台”为基础研制的一颗新技术试验验证卫星，重量达8吨，是目前我国研制的地球同步轨道发射重量最重的卫星，也是技术含金量最高的一颗卫星。 实践二十号携带了不少“黑科技”。它有着我国迄今为止面积最大、翼展最长、展开方式最复杂的太阳翼，能够低速转动，保证始终朝向太阳。它还配备了国内功率最大的电源控制器，确保太阳翼提供的超强电流“听话地”流到卫星每一个角落，维持卫星的健康运转。 那么，这颗卫星到底有什么作用？ 用中国航天科技集团公司五院总工程师、实践二十号卫星总指挥周志成院士的话来说，“实践二十号卫星首要任务是验证‘东方红五号卫星平台’的技术稳定性，由于搭载了十多项国际领先的技术验证载荷，也兼具新技术技术验证的使命。以‘实践’命名卫星，就是对该星所承担的探索意义的最好诠释。” 据介绍，“东方红五号卫星平台”是我国自主开发的新一代大型地球同步轨道卫星平台，单机国产化率达100%，能满足未来20年的大容量卫星应用需求。实践二十号作为该平台的首飞试验星，它的成功发射将对我国通信卫星事业的发展起到重要作用。 2 火箭的历史现代火箭诞生自罗伯特·高达德将超音速的喷嘴装上液态燃料火箭引擎燃烧室。这种喷嘴将燃烧室中的热气体转成较冷的极超音速喷射气体，使推进力增加超过二倍，且巨幅地增加了效率。在此之前，早期的火箭因为热能随气体排放被浪费了，使效率低下。 1920年，高达德出版了《A method of reaching extreme Altitudes&gt;,这是在齐奥尔科夫斯基之后第一本认真讨论使用火箭在太空旅行的著作。这本书引起全世界的注意，同时获得赞赏与嘲笑，特别是在认为火箭可以到达月球的方面。纽约时报的社论甚至指控高达德欺骗世人，认为火箭在太空中不可能运作。 1923年，赫尔曼·奥伯特在幕尼黑大学拒决了他的博士论文后，将其一个版本出版成为《飞向行星太空的火箭》。 1926年三月16日，罗伯特·高达德在美国马萨诸塞州奥本镇发射了世界第一枚液态燃料火箭。1920年代，美国，奥地利，英国，捷克，斯洛伐克，法国，意大利，德国及俄国相继出现研究火箭的组织，1920年代中期，德国科学家开始实验能到达高空及长距离的液态推进火箭。一群业余火箭工程师在1927年组成德国火箭学会，而在1931年发射了一枚液态推进火箭（使用氧气和汽油）。 3 火箭中的物理学知识]]></content>
      <categories>
        <category>物理</category>
      </categories>
      <tags>
        <tag>火箭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kids_math_study_Newton]]></title>
    <url>%2F2019%2F12%2F10%2Fkids-math-study-Newton%2F</url>
    <content type="text"><![CDATA[1 牛顿和万有引力 2 万有引力的故事 3 万有引力的公式]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>小孩学数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs_study]]></title>
    <url>%2F2019%2F07%2F05%2Fnodejs-study%2F</url>
    <content type="text"><![CDATA[1 nodejs介绍2 nodejs使用场景3 nodejs工程布局4 nodejs实战搭建一个股票质量评分系统 4.1 前端vue实现功能： 1 输入股票id或者名字，查看股票图形；2 查看股票得分； 4.2 后端express1 给予前端股票数据，或者一份完整的展示模型；2 给予客户端一个分数，比如分：政策面，经济面，市场面。]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ta_lib_study]]></title>
    <url>%2F2019%2F04%2F19%2Fta-lib-study%2F</url>
    <content type="text"><![CDATA[1 talib介绍1.1 总体Function Groups Overlap Studies 重叠的研究Momentum Indicators 动量指标Volume Indicators 量指标Volatility Indicators 波动性指标Price Transform 价格指标Cycle Indicators 循环指标Pattern Recognition 模式识别Statistic Functions 统计功能Math Transform 数学变换Math Operators 数学运算符 1.1.1 Overlap Studies 重叠的研究BBANDS Bollinger Bands #布林带DEMA Double Exponential Moving Average #双指数移动平均线EMA Exponential Moving Average #指数滑动平均HT_TRENDLINE Hilbert Transform - Instantaneous Trendline #希尔伯特变换瞬时趋势KAMA Kaufman Adaptive Moving Average #卡玛考夫曼自适应移动平均MA Moving average #均线MAMA MESA Adaptive Moving Average #自适应移动平均MAVP Moving average with variable period #变周期移动平均MIDPOINT MidPoint over period #在周期的中点MIDPRICE Midpoint Price over period #中间时段价格SAR Parabolic SAR #抛物线转向指标SAREXT Parabolic SAR - ExtendedSMA Simple Moving AverageT3 Triple Exponential Moving Average (T3)TEMA Triple Exponential Moving AverageTRIMA Triangular Moving AverageWMA Weighted Moving Average 1.1.2 Momentum Indicators 动量指标ADX Average Directional Movement IndexADXR Average Directional Movement Index RatingAPO Absolute Price OscillatorAROON AroonAROONOSC Aroon OscillatorBOP Balance Of PowerCCI Commodity Channel IndexCMO Chande Momentum OscillatorDX Directional Movement IndexMACD Moving Average Convergence/DivergenceMACDEXT MACD with controllable MA typeMACDFIX Moving Average Convergence/Divergence Fix 12/26MFI Money Flow IndexMINUS_DI Minus Directional IndicatorMINUS_DM Minus Directional MovementMOM MomentumPLUS_DI Plus Directional IndicatorPLUS_DM Plus Directional MovementPPO Percentage Price OscillatorROC Rate of change : ((price/prevPrice)-1)100ROCP Rate of change Percentage: (price-prevPrice)/prevPriceROCR Rate of change ratio: (price/prevPrice)ROCR100 Rate of change ratio 100 scale: (price/prevPrice)100RSI Relative Strength IndexSTOCH StochasticSTOCHF Stochastic FastSTOCHRSI Stochastic Relative Strength IndexTRIX 1-day Rate-Of-Change (ROC) of a Triple Smooth EMAULTOSC Ultimate OscillatorWILLR Williams’ %R 1.1.3 Volume Indicators 量指标1.1.4 Volatility Indicators 波动性指标1.1.5 Price Transform 价格指标1.1.6 Cycle Indicators 循环指标1.1.7 Pattern Recognition 模式识别1.1.8 Statistic Functions 统计功能1.1.9 Math Transform 数学变换1.1.10 Math Operators 数学运算符1.2 细节python-ta-lib talib的简称是Technical Analysis Library，主要功能是计算股价的技术分析指标。先简单看看Talib都给我们提供了那些计算技术指标的函数，按技术指标的类型示例如下： 1234函数名：CDL2CROWS名称：Two Crows 两只乌鸦简介：三日K线模式，第一天长阳，第二天高开收阴，第三天再次高开继续收阴，收盘比前一日收盘价低，预示股价下跌。例子：integer = CDL2CROWS(open, high, low, close) 1234函数名：CDL3STARSINSOUTH名称：Three Stars In The South 南方三星简介：三日K线模式，与大敌当前相反，三日K线皆阴，第一日有长下影线，第二日与第一日类似，K线整体小于第一日，第三日无下影线实体信号，成交价格都在第一日振幅之内，预示下跌趋势反转，股价上升。例子：integer = CDL3STARSINSOUTH(open, high, low, close) 1234函数名 : MA名称：Moving average 移动平均值简介：移动平均值是在一定范围内的价格平均值例子：ma = MA(close, timeperiod=30, matype=0) 1234函数名：ADX名称：Average Directional Movement Index 平均趋向指数简介：ADX指数是反映趋向变动的程度，而不是方向的本身。例子：adx = ADX(high, low, close, timeperiod=14) 1234函数名：ATR名称：Average True Range 平均真实波幅简介：主要用来衡量价格的波动。因此，这一技术指标并不能直接反映价格走向及其趋势稳定性，而只是表明价格波动的程度。例子：atr = ATR(high, low, close, timeperiod=14) 12345函数名：OBV名称：On Balance Volume 能量潮简介：通过统计成交量变动的趋势推测股价趋势计算公式：以某日为基期，逐日累计每日上市股票总成交量，若隔日指数或股票上涨，则基期OBV加上本日成交量为本日OBV。隔日指数或股票下跌，则基期OBV减去本日成交量为本日OBV例子：obv = OBV(close, volume) 12 12 12 12 2 talib使用3 talib原理研究]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>量化分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Simons_Fund]]></title>
    <url>%2F2019%2F04%2F08%2FSimons-Fund%2F</url>
    <content type="text"><![CDATA[1 Simons简介西蒙斯是个数学天才，20岁毕业于 MIT 数学系，23岁在 UC Berkeley 拿到 PhD，24岁去 Harvard 任教，26岁被国防分析研究所（IDA）请到 Princeton，表面上搞研究，实则为军方破解密码。后来因反对越战而离职，30岁在 Stony Brook 当上数学学院院长…… 1998年，Simons 60 岁，纽约州立大学石溪分校的某个会议上展示 Simons 早期生活的海报。 37岁那年，西蒙斯获得了几何学界的诺贝尔奖：韦布伦奖（Oswald Veblen Prize）。 感觉差不多刷到头了，是时候换个行业，开启新一轮的人生。 于是西蒙斯成立了一家名叫“文艺复兴”（Renaissance Tech.）的对冲基金。从名字上看，这是要挑战文艺复兴时期那批通才的跨界难度。不幸的是，他又成功了。西蒙斯在基金界的地位，就好比武当张三丰，他在华尔街之外开创了一个新的投资流派。这么说吧，现在基金风格分为三种，分别叫：巴菲特、索罗斯、西蒙斯。 为了纪念当年的韦布伦奖，西蒙斯将旗舰产品命名为“大奖章基金”（Medallion Fund）。这个基金就像印钞机，二十多年来一直在赚钱，年均收益率大概是巴菲特的两倍。一般的基金收费按照“双二标准”，管理费2%，分成20%；但西蒙斯有钱任性，非得管理费5%，分成36%。即便如此，大奖章依然遭到疯抢，最后不得不停止对外发售，只受理自己人的钱。2008年金融危机爆发，基金界哀鸿遍野，但大奖章依然盈利了80%，而西蒙斯个人收入25亿美元。美国国会召开危机聆讯，第一个通知的就是他，要求当庭发誓没有乱来： 如图所示，那个打着红领带的老头。他的右侧是大家比较熟悉的 George Soros，左侧是 John Paulson 和 Philip Falcone ——这两位的基金后来也挂掉了。只有西蒙斯稳稳地赚到退休，并且在退休之后还装了个逼，大意是：我人都走了，基金还在那赚钱，这让我觉得自己并不重要，有点失落…… Simons 博士和他的妻子 Marilyn。Marilyn 是一位经济学家，也是他们基金会的主席 值得一提的是，西蒙斯先生跟中国颇有渊源。他有两位好友，分别闪耀在数学界和物理界，一位叫陈省身，一位叫杨振宁。 西蒙斯这辈子最大的成就，不是一年赚到数十亿美元，而是和陈省身合作的“陈-西蒙斯定理”——这后来成为微分拓扑学的基础性理论。就在西蒙斯前往 Stony Brook 掌舵数学的时候，杨振宁也正好去 Stony Brook 掌舵物理。当时杨振宁已经通过“宇称不守恒”拿到了诺贝尔奖，正试图建立一个更加强大的规范场理论，但在纤维丛等数学细节上遇到了困难。西蒙斯引入和乐群帮他扫清了数学障碍，从而建立了近代物理的基础——“杨-米尔斯理论”。这是一个相对论量级的成果，区区诺贝尔奖已不足以表彰其伟大。所以我们看到今天 Stony Brook 的物理学机构，名叫“杨振宁理论物理研究所”；而几何学机构，名叫“西蒙斯几何物理中心”。 因为陈省身出自清华数学系，而杨振宁出自清华物理系，所以在清华百年校庆之际，西蒙斯以福布斯土豪的身份跑来捐了一座楼。有意思的是，小楼冠以陈省身之名，然后供杨振宁住在里面。 2 Simons基金类型简介3 Simons基金类型深入研究]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>基金</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go_study]]></title>
    <url>%2F2019%2F03%2F21%2Fgo-study%2F</url>
    <content type="text"><![CDATA[1 whatGo作为Google2009年推出的语言，其被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 Go语言主要用作服务器端开发，其定位是用来开发“大型软件”的，适合于很多程序员一起开发大型软件，并且开发周期长，支持云计算的网络服务。Go语言能够让程序员快速开发，并且在软件不断的增长过程中，它能让程序员更容易地进行维护和修改。它融合了传统编译型语言的高效性和脚本语言的易用性和富于表达性。 Go语言作为服务器编程语言，很适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；网络编程方面，Go语言广泛应用于Web应用、API应用、下载应用等；除此之外，Go语言还可用于内存数据库和云平台领域，目前国外很多云平台都是采用Go开发。 Go适合做什么 很多朋友可能知道Go语言的优势在哪，却不知道Go语言适合用于哪些地方。 其实Go语言主要用作服务器端开发，其定位是用来开发“大型软件”的，适合于很多程序员一起开发大型软件，并且开发周期长，支持云计算的网络服务。Go语言能够让程序员快速开发，并且在软件不断的增长过程中，它能让程序员更容易地进行维护和修改。它融合了传统编译型语言的高效性和脚本语言的易用性和富于表达性。 Go语言作为服务器编程语言，很适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；网络编程方面，Go语言广泛应用于Web应用、API应用、下载应用等；除此之外，Go语言还可用于内存数据库和云平台领域，目前国外很多云平台都是采用Go开发。 2 why1、学习曲线 它包含了类C语法、GC内置和工程工具。这一点非常重要，因为Go语言容易学习，所以一个普通的大学生花一个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内Go流行的原因之一。 2、效率 Go拥有接近C的运行效率和接近PHP的开发效率，这就很有利的支撑了上面大家追求快速的需求。 3、出身名门、血统纯正 之所以说Go出身名门，是因为我们知道Go语言出自Google公司，这个公司在业界的知名度和实力自然不用多说。Google公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从Go语言的发展态势来看，Google对它这个新的宠儿还是很看重的，Go自然有一个良好的发展前途。我们看看Go语言的主要创造者，血统纯正这点就可见端倪了。 4、自由高效：组合的思想、无侵入式的接口 Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程以及函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。 5、强大的标准库 这包括互联网应用、系统编程和网络编程。Go里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。 6、部署方便：二进制文件、Copy部署 我相信这一点是很多人选择Go的最大理由，因为部署太方便了，所以现在也有很多人用Go开发运维程序。 7、简单的并发 它包含了降低心智的并发和简易的数据同步，我觉得这是Go最大的特色。之所以写正确的并发、容错和可扩展的程序如此之难，是因为我们用了错误的工具和错误的抽象，Go可以说这一块做的相当简单。 8、稳定性 Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。 3 how]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[groovy_study]]></title>
    <url>%2F2019%2F03%2F19%2Fgroovy-study%2F</url>
    <content type="text"><![CDATA[1 what1.1 groovy简介什么是Groovy？ 一种运行于JVM上的轻量化的动态编程语言，其基于Java，并吸收了其它多种语言的优点（Smalltalk、Python、Ruby等），可以理解为是Java的动态扩展版。 Groovy是一种基于JVM（Java虚拟机）的敏捷动态开发语言。它是一种成熟的面向对象编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。作为Java程序员，即便以前没有接触过Groovy，也可以快速学习。 总结： Groovy 就是 Java，只是缺少了过去使用Java的许多语法规则。Groovy 是没有类型、没有修改符、没有 return、没有Iterator、不需要导入集合的 Java。简而言之，Groovy 就是丢掉了许多包袱的 Java，这些包袱可能会压垮 Java 项目。但是在幕后，Groovy 就是 Java。 2 why3 how]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>groovy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[data_visualization]]></title>
    <url>%2F2019%2F03%2F04%2Fdata-visualization%2F</url>
    <content type="text"><![CDATA[1 数据可视化介绍1.1 D3数据可视化D3 的全称是（Data-Driven Documents），顾名思义可以知道是一个被数据驱动的文档。就是一个 JavaScript 的函数库，使用它主要是用来做数据可视化的。 D3 提供了各种简单易用的函数，大大简化了 JavaScript 操作数据的难度。由于它本质上是 JavaScript ，所以用 JavaScript 也是可以实现所有功能的，但它能大大减小你的工作量，尤其是在数据可视化方面，D3 已经将生成可视化的复杂步骤精简到了几个简单的函数，你只需要输入几个简单的数据，就能够转换为各种绚丽的图形。 D3 是一个开源项目，作者是纽约时报的工程师。D3 项目的代码托管于 GitHub。 1.1.1 D3初阶1.1.1.1 第一个程序Hello World12345678910&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;HelloWorld&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World 1&lt;/p&gt; &lt;p&gt;Hello World 2&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 如果想用JavaScript来更改这两行文字: 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;HelloWorld&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World 1&lt;/p&gt; &lt;p&gt;Hello World 2&lt;/p&gt; &lt;script&gt; var paragraphs = document.getElementsByTagName("p"); for (var i = 0; i &lt; paragraphs.length; i++) &#123; var paragraph = paragraphs.item(i); paragraph.innerHTML = "I like dog."; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 如果使用D3.js呢 1234567891011121314&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;HelloWorld&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World 1&lt;/p&gt; &lt;p&gt;Hello World 2&lt;/p&gt; &lt;script src="http://d3js.org/d3.v3.min.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; d3.select("body").selectAll("p").text("www.ourd3js.com"); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 1.1.1.2 DashBoard body{ width:1060px; margin:50px auto;}path { stroke: #fff; }path:hover { opacity:0.9; }rect:hover { fill:blue; }.axis { font: 10px sans-serif; }.legend tr{ border-bottom:1px solid grey; }.legend tr:first-child{ border-top:1px solid grey; } .axis path,.axis line { fill: none; stroke: #000; shape-rendering: crispEdges;} .x.axis path { display: none; }.legend{ margin-bottom:76px; display:inline-block; border-collapse: collapse; border-spacing: 0px;}.legend td{ padding:4px 5px; vertical-align:bottom;}.legendFreq, .legendPerc{ align:right; width:50px;} function dashboard(id, fData){ var barColor = 'steelblue'; function segColor(c){ return {low:"#807dba", mid:"#e08214",high:"#41ab5d"}[c]; } // compute total for each state. fData.forEach(function(d){d.total=d.freq.low+d.freq.mid+d.freq.high;}); // function to handle histogram. function histoGram(fD){ var hG={}, hGDim = {t: 60, r: 0, b: 30, l: 0}; hGDim.w = 500 - hGDim.l - hGDim.r, hGDim.h = 300 - hGDim.t - hGDim.b; //create svg for histogram. var hGsvg = d3.select(id).append("svg") .attr("width", hGDim.w + hGDim.l + hGDim.r) .attr("height", hGDim.h + hGDim.t + hGDim.b).append("g") .attr("transform", "translate(" + hGDim.l + "," + hGDim.t + ")"); // create function for x-axis mapping. var x = d3.scale.ordinal().rangeRoundBands([0, hGDim.w], 0.1) .domain(fD.map(function(d) { return d[0]; })); // Add x-axis to the histogram svg. hGsvg.append("g").attr("class", "x axis") .attr("transform", "translate(0," + hGDim.h + ")") .call(d3.svg.axis().scale(x).orient("bottom")); // Create function for y-axis map. var y = d3.scale.linear().range([hGDim.h, 0]) .domain([0, d3.max(fD, function(d) { return d[1]; })]); // Create bars for histogram to contain rectangles and freq labels. var bars = hGsvg.selectAll(".bar").data(fD).enter() .append("g").attr("class", "bar"); //create the rectangles. bars.append("rect") .attr("x", function(d) { return x(d[0]); }) .attr("y", function(d) { return y(d[1]); }) .attr("width", x.rangeBand()) .attr("height", function(d) { return hGDim.h - y(d[1]); }) .attr('fill',barColor) .on("mouseover",mouseover)// mouseover is defined below. .on("mouseout",mouseout);// mouseout is defined below. //Create the frequency labels above the rectangles. bars.append("text").text(function(d){ return d3.format(",")(d[1])}) .attr("x", function(d) { return x(d[0])+x.rangeBand()/2; }) .attr("y", function(d) { return y(d[1])-5; }) .attr("text-anchor", "middle"); function mouseover(d){ // utility function to be called on mouseover. // filter for selected state. var st = fData.filter(function(s){ return s.State == d[0];})[0], nD = d3.keys(st.freq).map(function(s){ return {type:s, freq:st.freq[s]};}); // call update functions of pie-chart and legend. pC.update(nD); leg.update(nD); } function mouseout(d){ // utility function to be called on mouseout. // reset the pie-chart and legend. pC.update(tF); leg.update(tF); } // create function to update the bars. This will be used by pie-chart. hG.update = function(nD, color){ // update the domain of the y-axis map to reflect change in frequencies. y.domain([0, d3.max(nD, function(d) { return d[1]; })]); // Attach the new data to the bars. var bars = hGsvg.selectAll(".bar").data(nD); // transition the height and color of rectangles. bars.select("rect").transition().duration(500) .attr("y", function(d) {return y(d[1]); }) .attr("height", function(d) { return hGDim.h - y(d[1]); }) .attr("fill", color); // transition the frequency labels location and change value. bars.select("text").transition().duration(500) .text(function(d){ return d3.format(",")(d[1])}) .attr("y", function(d) {return y(d[1])-5; }); } return hG; } // function to handle pieChart. function pieChart(pD){ var pC ={}, pieDim ={w:250, h: 250}; pieDim.r = Math.min(pieDim.w, pieDim.h) / 2; // create svg for pie chart. var piesvg = d3.select(id).append("svg") .attr("width", pieDim.w).attr("height", pieDim.h).append("g") .attr("transform", "translate("+pieDim.w/2+","+pieDim.h/2+")"); // create function to draw the arcs of the pie slices. var arc = d3.svg.arc().outerRadius(pieDim.r - 10).innerRadius(0); // create a function to compute the pie slice angles. var pie = d3.layout.pie().sort(null).value(function(d) { return d.freq; }); // Draw the pie slices. piesvg.selectAll("path").data(pie(pD)).enter().append("path").attr("d", arc) .each(function(d) { this._current = d; }) .style("fill", function(d) { return segColor(d.data.type); }) .on("mouseover",mouseover).on("mouseout",mouseout); // create function to update pie-chart. This will be used by histogram. pC.update = function(nD){ piesvg.selectAll("path").data(pie(nD)).transition().duration(500) .attrTween("d", arcTween); } // Utility function to be called on mouseover a pie slice. function mouseover(d){ // call the update function of histogram with new data. hG.update(fData.map(function(v){ return [v.State,v.freq[d.data.type]];}),segColor(d.data.type)); } //Utility function to be called on mouseout a pie slice. function mouseout(d){ // call the update function of histogram with all data. hG.update(fData.map(function(v){ return [v.State,v.total];}), barColor); } // Animating the pie-slice requiring a custom function which specifies // how the intermediate paths should be drawn. function arcTween(a) { var i = d3.interpolate(this._current, a); this._current = i(0); return function(t) { return arc(i(t)); }; } return pC; } // function to handle legend. function legend(lD){ var leg = {}; // create table for legend. var legend = d3.select(id).append("table").attr('class','legend'); // create one row per segment. var tr = legend.append("tbody").selectAll("tr").data(lD).enter().append("tr"); // create the first column for each segment. tr.append("td").append("svg").attr("width", '16').attr("height", '16').append("rect") .attr("width", '16').attr("height", '16') .attr("fill",function(d){ return segColor(d.type); }); // create the second column for each segment. tr.append("td").text(function(d){ return d.type;}); // create the third column for each segment. tr.append("td").attr("class",'legendFreq') .text(function(d){ return d3.format(",")(d.freq);}); // create the fourth column for each segment. tr.append("td").attr("class",'legendPerc') .text(function(d){ return getLegend(d,lD);}); // Utility function to be used to update the legend. leg.update = function(nD){ // update the data attached to the row elements. var l = legend.select("tbody").selectAll("tr").data(nD); // update the frequencies. l.select(".legendFreq").text(function(d){ return d3.format(",")(d.freq);}); // update the percentage column. l.select(".legendPerc").text(function(d){ return getLegend(d,nD);}); } function getLegend(d,aD){ // Utility function to compute percentage. return d3.format("%")(d.freq/d3.sum(aD.map(function(v){ return v.freq; }))); } return leg; } // calculate total frequency by segment for all state. var tF = ['low','mid','high'].map(function(d){ return {type:d, freq: d3.sum(fData.map(function(t){ return t.freq[d];}))}; }); // calculate total frequency by state for all segment. var sF = fData.map(function(d){return [d.State,d.total];}); var hG = histoGram(sF), // create the histogram. pC = pieChart(tF), // create the pie-chart. leg= legend(tF); // create the legend. } var freqData=[ {State:'AL',freq:{low:4786, mid:1319, high:249}} ,{State:'AZ',freq:{low:1101, mid:412, high:674}} ,{State:'CT',freq:{low:932, mid:2149, high:418}} ,{State:'DE',freq:{low:832, mid:1152, high:1862}} ,{State:'FL',freq:{low:4481, mid:3304, high:948}} ,{State:'GA',freq:{low:1619, mid:167, high:1063}} ,{State:'IA',freq:{low:1819, mid:247, high:1203}} ,{State:'IL',freq:{low:4498, mid:3852, high:942}} ,{State:'IN',freq:{low:797, mid:1849, high:1534}} ,{State:'KS',freq:{low:162, mid:379, high:471}} ]; dashboard('#dashboard',freqData); 1.1.2 D3中阶1.1.3 D3高阶1.1.4 javascript TDDjasmine 1.2 python数据可视化Seaborn vs Matplotlib 正如你所知道的，Seaborn是比Matplotlib更高级的免费库，特别地以数据可视化为目标，但他要比这一切更进一步：他解决了用Matplotlib的2个最大问题，正如Michael Waskom所说的：Matplotlib试着让简单的事情更加简单，困难的事情变得可能，那么Seaborn就是让困难的东西更加简单。用Matplotlib最大的困难是其默认的各种参数，而Seaborn则完全避免了这一问题。]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker_study]]></title>
    <url>%2F2019%2F02%2F28%2Fdocker-study%2F</url>
    <content type="text"><![CDATA[1 docker的前世今生1.1 前世 docker Container Engine LXC/LibcontainerLibcontainer provides a native Go implementation for creating containers with namespaces, cgroups, capabilities, and filesystem access controls. It allows you to manage the lifecycle of the container performing additional operations after the containeris created. 组成 CGroups 限制资源 Cpu Memory Blkio Freezer Namespaces 隔离环境 MNT PID NET IPC USER UTS /var/lib/docker探底 aufs graph repositories-aufs architecture 1.2 今生2 docker使用2.1 基本属性2.2 实践2.2.1 本地部署Jenkins3 docker深入解析3.1 docker之操作系统 Docker之操作系统Alpine Alpine 操作系统是一个面向安全的轻型 Linux 发行版。它不同于通常 Linux 发行版，Alpine 采用了 musl libc 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox 又完善的多，因此得到开源社区越来越多的青睐。在保持瘦身的同时，Alpine 还提供了自己的包管理工具 apk，可以通过 https://pkgs.alpinelinux.org/packages 网站上查询包信息，也可以直接通过 apk 命令直接查询和安装各种软件。 Alpine 由非商业组织维护的，支持广泛场景的 Linux发行版，它特别为资深/重度Linux用户而优化，关注安全，性能和资源效能。Alpine 镜像可以适用于更多常用场景，并且是一个优秀的可以适用于生产的基础系统/环境。 Alpine Docker 镜像也继承了 Alpine Linux 发行版的这些优势。相比于其他 Docker 镜像，它的容量非常小，仅仅只有 5 MB 左右（对比 Ubuntu 系列镜像接近 200 MB），且拥有非常友好的包管理机制。官方镜像来自 docker-alpine 项目。 目前 Docker 官方已开始推荐使用 Alpine 替代之前的 Ubuntu 做为基础镜像环境。这样会带来多个好处。包括镜像下载速度加快，镜像安全性提高，主机之间的切换更方便，占用更少磁盘空间等。 下表是官方镜像的大小比较： 12345REPOSITORY TAG IMAGE ID VIRTUAL SIZEalpine latest 4e38e38c8ce0 4.799 MBdebian latest 4d6ce913b130 84.98 MBubuntu latest b39b81afc8ca 188.3 MBcentos latest 8efe422e6104 210 MB 获取并使用官方镜像 由于镜像很小，下载时间往往很短，读者可以直接使用 docker run 指令直接运行一个 Alpine 容器，并指定运行的 Linux 指令，例如： 12$ docker run alpine echo '123'123 迁移至 Alpine 基础镜像 目前，大部分 Docker 官方镜像都已经支持 Alpine 作为基础镜像，可以很容易进行迁移。 例如： ubuntu/debian -&gt; alpinepython:2.7 -&gt; python:2.7-alpineruby:2.3 -&gt; ruby:2.3-alpine 另外，如果使用 Alpine 镜像替换 Ubuntu 基础镜像，安装软件包时需要用 apk 包管理器替换 apt 工具，如 1$ apk add --no-cache &lt;package&gt; Alpine 中软件安装包的名字可能会与其他发行版有所不同，可以在 https://pkgs.alpinelinux.org/packages 网站搜索并确定安装包名称。如果需要的安装包不在主索引内，但是在测试或社区索引中。那么可以按照以下方法使用这些安装包。 12$ echo "http://dl-4.alpinelinux.org/alpine/edge/testing" &gt;&gt; /etc/apk/repositories$ apk --update add --no-cache &lt;package&gt; apk命令详解 / # apk -hapk-tools 2.10.0, compiled for x86_64. Installing and removing packages: add Add PACKAGEs to ‘world’ and install (or upgrade) them, while ensuring that all dependencies are met del Remove PACKAGEs from ‘world’ and uninstall them System maintenance: fix Repair package or upgrade it without modifying main dependencies update Update repository indexes from all remote repositories upgrade Upgrade currently installed packages to match repositories cache Download missing PACKAGEs to cache and/or delete unneeded files from cache Querying information about packages: info Give detailed information about PACKAGEs or repositories list List packages by PATTERN and other criteria dot Generate graphviz graphs policy Show repository policy for packages Repository maintenance: index Create repository index file from FILEs fetch Download PACKAGEs from global repositories to a local directory verify Verify package integrity and signature manifest Show checksums of package contents Use apk –help for command-specific help.Use apk –help –verbose for a full command listing. This apk has coffee making abilities. 相关资源 Alpine 官网：http://alpinelinux.org/Alpine 官方仓库：https://github.com/alpinelinuxAlpine 官方镜像：https://hub.docker.com/_/alpine/Alpine 官方镜像仓库：https://github.com/gliderlabs/docker-alpine]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[our_earth]]></title>
    <url>%2F2019%2F02%2F22%2Four-earth%2F</url>
    <content type="text"><![CDATA[1 太阳系1.1 地球 这就是我们的地球，真漂亮。我们地球的体积是10832.073亿立方公里。 1.2 带上月球小弟弟 这是地球和月球的对比。一个地球有49个月球那么大。 1.3 还有兄弟们 还是地球最漂亮。这样看的话，我们真要好好爱护她。 1.4 还有两个大家伙 好家伙，海王星有58个地球大，天王星有65个地球大。 1.5 还有更大的 1.6 太阳 2 离开太阳系2.1 天狼星 2.2 北河三 2.3 大角星 2.4 参宿七 2.5 心大星 2.6 仙后座 2.7 天鹅座 2.8 大犬座 3 星系3.1 银河系我们所在的银河系，也叫Milky Way星系 3.2 lc1011 最左边最小的那是就是我们的银河系 那么Ic1011是最大了吗？ 你必须看得更远一点 3.3 星系群 每一个亮点都是一个星系 3.4 星空 然而， 星系群也不过是星空中的一个角落。 4 宇宙我们的宇宙和其它宇宙有着不同的自然规律。]]></content>
      <categories>
        <category>物理</category>
      </categories>
      <tags>
        <tag>天文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python_oo_study]]></title>
    <url>%2F2019%2F02%2F18%2Fpython-oo-study%2F</url>
    <content type="text"><![CDATA[1 python oo编程1.1 oo的通用概念面向对象编程(Object-oriented Programming,缩写：OOP)是软件工程中一种具有对象概念的编程范式(Programming Paradigm)，同时也是一种程序开发的抽象方针，与之对应的编程范式还有：函数式编程(Functional Programming)、过程式编程(Procedural Programming)、响应式编程(Reactive Programming)等。 一切皆为对象 在面向对象编程世界里，一切皆为对象，对象是程序的基本单元，对象把程序与数据封装起来提供对外访问的能力，提高软件的重用性，灵活性和扩展性。 对象与类 对象与类在面向对象编程中，最常见的表现就是基于类(Class)来表现的，每一个对象实例都有具体的类，即对象的类型。使用类的面向对象编程也称为基于类的编程(Class-based programming)，如常见的Java，C++；而与之类似的有基于原型的编程(Prototype-based programming)，如JavaScript。 类：定义对象的数据格式(属性类型)和可用过程(方法)，同时也可能包含类成员的数据(如，常量)和过程(如，静态方法)，类其实就是对象的类型/原型(prototype)。 对象：类的实例，通过类实例化出来的具体实例。 面向对象三大特征 面向对象的三大特征分别是：封装、继承、多态，这三者是面向对象编程的基本要素 封装(Encapsulation) 通过对象隐藏程序的具体实现细节，将数据与操作包装在一起，对象与对象之间通过消息传递机制实现互相通信（方法调用），具体的表现就是通过提供访问接口实现消息的传入传出。封装常常会通过控制访问权限来控制对象之间的互访权限，常见的访问权限：公有(public)，私有(private)，保护(protected)。某些语言可能还会提供更加具体的访问控制，如，Java的package。封装的意义：由于封装隐藏了具体的实现，如果实现的改变或升级对于使用方而言是无感知的，提高程序的可维护性；而且封装鼓励程序员把特定数据与对数据操作的功能打包在一起，有利于应用程序的去耦。 继承(Inheritance) 支持类的语言基本都支持继承，继承即类之间可以继承，通过继承得到的类称为子类，被继承的类为父类，子类相对于父类更加具体化。子类具有自己特有的属性和方法，并且子类使用父类的方法也可以覆盖(重写)父类方法，在某些语言中还支持多继承，但是也带来了覆盖的复杂性。继承的意义：继承是代码复用的基础机制 多态(Polymorphism) 多态发生在运行期间，即子类型多态，指的是子类型是一种多态的形式，不同类型的对象实体有统一接口，相同的消息给予不同的对象会引发不同的动作。多态的意义：提供了编程的灵活性，简化了类层次结构外部的代码，使编程更加注重关注点分离(Separation of concerns，SoC) 其它特征 抽象(Abstraction)能够把复杂问题通过抽象简单化，可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。 组合(Composition)对象可以在其实例变量中包含其他对象 1.2 python中oo的特殊之处2 总结]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LSTM_Study]]></title>
    <url>%2F2019%2F02%2F16%2FLSTM-Study%2F</url>
    <content type="text"><![CDATA[1 LSTM介绍LSTM（Long Short-Term Memory）算法作为深度学习方法的一种，在介绍LSTM算法之前，有必要介绍一下深度学习（Deep Learning）的一些基本背景。 LSTM算法全称为Long short-term memory，最早由 Sepp Hochreiter和Jürgen Schmidhuber于1997年提出[6]，是一种特定形式的RNN（Recurrent neural network，循环神经网络），而RNN是一系列能够处理序列数据的神经网络的总称。这里要注意循环神经网络和递归神经网络（Recursive neural network）的区别。 一般地，RNN包含如下三个特性： 循环神经网络能够在每个时间节点产生一个输出，且隐单元间的连接是循环的； 循环神经网络能够在每个时间节点产生一个输出，且该时间节点上的输出仅与下一时间节点的隐单元有循环连接； 循环神经网络包含带有循环连接的隐单元，且能够处理序列数据并输出单一的预测。 RNN还有许多变形，例如双向RNN（Bidirectional RNN）等。然而，RNN在处理长期依赖（时间序列上距离较远的节点）时会遇到巨大的困难，因为计算距离较远的节点之间的联系时会涉及雅可比矩阵的多次相乘，这会带来梯度消失（经常发生）或者梯度膨胀（较少发生）的问题，这样的现象被许多学者观察到并独立研究。为了解决该问题，研究人员提出了许多解决办法，例如ESN（Echo State Network），增加有漏单元（Leaky Units）等等。其中最成功应用最广泛的就是门限RNN（Gated RNN），而LSTM就是门限RNN中最著名的一种。有漏单元通过设计连接间的权重系数，从而允许RNN累积距离较远节点间的长期联系；而门限RNN则泛化了这样的思想，允许在不同时刻改变该系数，且允许网络忘记当前已经累积的信息。 LSTM就是这样的门限RNN，其单一节点的结构如下图1所示。LSTM的巧妙之处在于通过增加输入门限，遗忘门限和输出门限，使得自循环的权重是变化的，这样一来在模型参数固定的情况下，不同时刻的积分尺度可以动态改变，从而避免了梯度消失或者梯度膨胀的问题。 2 LSTM实践3 LSTM总结]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tuchart_study]]></title>
    <url>%2F2019%2F02%2F12%2Ftuchart-study%2F</url>
    <content type="text"><![CDATA[1 效果展示 使用 1）先pip show tuchart，得到tuchart的安装位置2）然后到tuchart安装目录下，python main.py 2 源码解析2.1 qtpy介绍2.1.13 增量开发]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>股票图示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DSL]]></title>
    <url>%2F2019%2F01%2F31%2FDSL%2F</url>
    <content type="text"><![CDATA[0 前言0.1 为什么DSL很重要 提升程序员的生产力 1）优势一：擅长在程序的某些特定地方发挥作用，并且让它们容易理解，进而提高编写、维护的速度，也会减少bug；2）优势二：DSL往往短小易读，所以非程序员也能看懂这些驱动业务的代码，DSL表达业务，使得程序员和客户，或者和BA之间有非常顺畅的沟通。 1 叙述1.1 入门例子 是什么让内部DSL不同于通常的API呢？ 内部DSL的另一个术语，连贯接口（fluent interface）。它强调，内部DSL实际上只是某种形式的API，只不过其设计考虑了连贯性难以琢磨的质量。 Domain Model &amp; 语义模型 &amp; 抽象语法树 以状态机模型为例： 留个问题，Domain Model &amp; 语义模型 &amp; 抽象语法树,这3者有何不同？ 同时也要注意：对于一个设计良好的DSL而言，语义模型至关重要。 适应性模型 这里，DSL所带来的益处与状态机紧密相关，其所组成的某个特定模型就扮演了系统程序的角色。要改变状态机的行为，就需要修改模型中的对象及其相互关系。这种风格的模型通常称为“适应性模型”。 使用适应性模型是一种好的方式，DSL则简化了为这种模型编程的方式。有人把这种使用DSL的方式称为声明式编程。 使用代码生成 在上面谈到处理DSL时，是组装“语义模型”，然后执行语义模型，这称之为解释。在软件圈子里，解释是个棘手的词语，然而我们希望这里严格限制为立即执行。 与解释相对的就是编译。在DSL的上下文里，编译方式通常指的是代码生成。 用状态机解释这个差异有点困难，因此换用另外一个例子。用某种规则判定人们是否符合某种资格，也许是为了满足保险资格。 如果是解释，资格判定处理器会解析规则，在执行时加载语义模型，也许是启动时加载。当检查某个候选人时，它会对这个候选人运行语义模型，获得一个结果。 如果是编译，解析器会加载语义模型，把它当作资格判定处理器构建过程的一部分。在构建期间，DSL处理器会产生一些代码，这些代码经过编译、打包，并且纳入资格判定处理器，也可能当作某种共享库。然后运行这段中间代码，对候选人进行评估。 解释型： 编译型： 总结时还是要突出下： 首先要有语义模型，它是DSL工作的核心。 使用语言工作台 目前没看到特定的工作台，但是这是一个方向。 可视化 可视化有助于展示，且其也是基于语义模型。 1.2 使用DSL1.2.1 定义DSL1.3 实现DSL1.4 实现内部DSL1.5 实现外部DSL1.6 内部DSL vs 外部DSL1.7 其他计算模型概述1.8 代码生成1.9 语言工作台2 通用主题2.1 各种DSL2.2 语义模型2.3 符号表2.4 语境变量2.5 构造型生成器2.6 宏2.7 通知3 外部DSL主题3.1 分隔符指导翻译3.2 语法指导翻译3.3 BNF3.4 基于正则表达式表的词法分析器3.5 递归下降法语法解析器3.6 解析器组合子3.7 解析器生成器3.8 树的构建3.9 嵌入式语法翻译3.10 内嵌解释器3.11 外加代码3.12 可变分词方式3.13 嵌套的运算符表达式3.14 以换行符作为分隔符3.15 外部DSL拾遗4 内部DSL主题4.1 表达式生成器4.2 函数序列4.3 嵌套函数4.4 方法级联4.5 对象范围4.6 闭包4.7 嵌套闭包4.8 列表的字面构造4.9 Literal Map4.10 动态接收4.11 标注4.12 解析树操作4.13 类符号表4.14 文本润色4.15 为字面量提供扩展5 其它计算模型5.1 适应性模型5.2 决策表5.3 依赖网络5.4 产生式规则系统5.5 状态机6 代码生成6.1 基于转换器的代码生成6.2 模板话的生成器6.3 嵌入助手6.4 基于模型的代码生成6.5 无视模型的代码生成6.6 代沟]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>DSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Turing Award]]></title>
    <url>%2F2019%2F01%2F30%2FTuring-Award%2F</url>
    <content type="text"><![CDATA[历届图灵奖 (Turing award)得奖名单 原文：https://blog.csdn.net/bitcarmanlee/article/details/52003756 1 汇总Turing奖最早设立于1966年，是美国计算机协会在计算机技术方面所授予的最高奖项，被喻为计算机界的诺贝尔奖。它是以英国数学天才Alan Turing先生的名字命名的，Alan Turing先生对早期计算的理论和实践做出了突出的贡献。图灵奖主要授予在计算机技术领域做出突出贡献的个人，而这些贡献必须对计算机科学与技术有长远而重要的影响。1966年，A. J. Perlis因其在新一代编程技术和编译架构方面的贡献成为图灵奖的第一个得主。每年，美国计算机协会将要求提名人推荐本年度的图灵奖候选人，并附加一份200到500字的文章，说明被提名者为什么应获此奖。任何人都可成为提名人，美国计算机协会将组成评选委员会对被提名者进行严格的审核，并最终确定当年的获奖者。 年份 姓名 贡献 1966 艾伦·佩利 高级程序设计技巧，编译器构造 1967 莫里斯·威尔克斯 存储过程式计算机EDSAC，EDSAC 2，程序库 1968 理查德·卫斯里·汉明 数值方法，自动编码系统，错误检测和纠错码 1969 马文·闵斯基 人工智能 1970 詹姆斯·维尔金森 数值分析，线性代数，倒退错误分析 1971 约翰·麦卡锡) 人工智能 1972 艾兹格·迪科斯彻 程序设计语言的科学与艺术 1973 查理士·巴赫曼 数据库技术 1974 高德纳 算法分析、程序设计语言的设计、程序设计 1975 艾伦·纽厄尔, 赫伯特·西蒙 人工智能，人类认知心理学和列表处理（list processing） 1976 迈克尔·拉宾, 达纳·斯科特 非确定性自动机 1977 约翰·巴克斯 高级编程系统，程序设计语言规范的形式化定义 1978 罗伯特·弗洛伊德 设计高效可靠软件的方法学 1979 肯尼斯·艾佛森 程序设计语言和数学符号，互动系统的设计，运用APL进行教学，程序设计语言的理论与实践 1980 东尼·霍尔 程序设计语言的定义与设计 1981 埃德加·科德 数据库系统，尤其是关系型数据库 1982 史提芬·古克 计算复杂度 1983 肯·汤普逊, 丹尼斯·里奇 UNIX操作系统和C语言 1984 尼克劳斯·维尔特 程序设计语言设计、程序设计 1985 理查德·卡普 算法理论，尤其是NP-完全性理论 1986 约翰·霍普克洛夫特, 罗伯特·塔扬 算法和数据结构的设计与分析 1987 约翰·科克 编译理论，大型系统的体系结构，及精简指令集（RISC）计算机的开发 1988 伊凡·苏泽兰 计算机图形学 1989 威廉·卡韩 数值分析 1990 费尔南多·考巴托 CTSS和Multics 1991 罗宾·米尔纳 LCF，ML语言，CCS 1992 巴特勒·兰普森 分布式，个人计算环境 1993 尤里斯·哈特马尼斯, 理查德·斯特恩斯 计算复杂度理论 1994 爱德华·费根鲍姆, 拉吉·瑞迪 大规模人工智能系统 1995 曼纽尔·布卢姆 计算复杂度理论，及其在密码学和程序校验上的应用 1996 阿米尔·伯努利 时序逻辑，程序与系统验证 1997 道格拉斯·恩格尔巴特 互动计算 1998 詹姆斯·尼古拉·格雷) 数据库与事务处理 1999 弗雷德里克·布鲁克斯 计算机体系结构，操作系统，软件工程 2000 姚期智 计算理论，包括伪随机数生成，密码学与通信复杂度 2001 奥利-约翰·达尔, 克利斯登·奈加特 面向对象编程 2002 罗纳德·李维斯特, 阿迪·萨莫尔, 伦纳德·阿德曼 公钥密码学（RSA加密算法） 2003 艾伦·凯 面向对象编程 2004 文特·瑟夫 TCP/IP协议 2005 彼得·诺尔 Algol 60语言 2006 法兰西斯·艾伦 优化编译器 2007 爱德蒙·克拉克, 艾伦·爱默生, 约瑟夫·斯发基斯 开发自动化方法检测计算机硬件和软件中的设计错误 2008 芭芭拉·利斯科夫 编程语言和系统设计的实践与理论 2009 查尔斯·萨克尔 帮助设计、制造第一款现代PC 2010 莱斯利·瓦伦特 对众多计算理论所做的变革性的贡献 2011 朱迪亚·珀尔 通过概率论和因果推理（英语：Causal reasoning）对人工智能领域作出的根本性贡献 2012 莎菲·戈德瓦塞尔, 希尔维奥·米卡利 在密码科学领域里，于复杂理论的基础之上，做出变革性工作；并领先发展出新的具有数学可证明性的有效验证机制 2013 莱斯利·兰波特 对于分布式及并形系统的理论与实践具有基础性贡献，尤其是诸如因果逻辑时序（causality and logical clocks）、安全性与存活度（safety and liveness）、复制状态机（replicated state machines）及循序一致性（英语：sequential consistency）（sequential consistency）等理论概念的发明 2014 迈克尔·斯通布雷克 对现代数据库的概念和实践作出的根本性贡献 2015 惠特菲尔德·迪菲, 马丁·赫尔曼 发明迪菲-赫尔曼密钥交换，对公开密钥加密技术有重大贡献 2 简介1966 A. J. Perlis因在新一代编程技术和编译架构方面的贡献而获奖1967 Maurice V. Wilkes因设计出第一台具有内置存储程序的计算机而获奖1968 Richard W. Hamming因在计数方法、自动编码系统、检测及纠正错码方面的贡献被授予图灵奖1969 Marvin Minsky 因对人工智能的贡献被授予图灵奖1970 J. H. Wilkinson因在利用数值分析方法来促进高速数字计算机的应用方面的研究而获奖1971 John McCarthy因对人工智能的贡献被授予图灵奖1972 Edsger W. Dijkstra因在编程语言方面的出众表现而获奖1973 Charles W. Bachman因在数据库方面的杰出贡献而获奖1974 Donald E. Knuth因设计和完成TEX(一种创新的具有很高排版质量的文档制作工具)而被授予该奖1975 Allen Newell和Herbert A.Simon因在人工智能、人类心理识别和列表处理等方面进行的基础研究而获奖1976 Michael O. Robin和Dana S. Scott因他们的论文”有限自动机与它们的决策问题”中所提出的非确定性机器这一很有价值的概念而获奖1977 John Backus因对可用的高级编程系统设计有深远和重大的影响而获奖1978 Robert W. F编程的算法方面的深远影响，并开创了包括剖析理论、编程语言的语义、自动程序检验、自动程序合成和算法分析在内的多项计算机子学科而被授予该奖1979 Kenneth E. Iverson因对程序设计语言理论、互动式系统及APL的贡献被授予该奖1980 C. Anthony R. Hoare因对程序设计语言的定义和设计所做的贡献而获奖1981 Edgar F. Codd因在数据库管理系统的理论和实践方面的贡献而获1982 Steven A. Cook因奠定了NP-Completeness理论的基础而获奖1983 Ken Thompson和Dennis M. Ritchie因在通用操作系统理论方面的突出贡献, 特别是对UNIX操作系统的推广的贡献而获奖1984 Niklaus Wirth因开发了EULER, ALGOL-W, MODULA和PASCAL一系列崭新的计算语言而获奖1985 Richard M. Karp因对算法理论的贡献而获奖1986 John E. Hopcroft因在算法及数据结构的设计和分析中所取得的决定性成果而获奖1987 John Cocke因在面向对象的编程语言和相关的编程技巧方面的贡献而获奖1988 Ivan E. Sutherland因在计算机图形学方面的贡献而获奖1989 William V.Kahan因在数值分析方面的贡献而获奖1990 Fernando J.Corbato因在开发大型多功能，可实现时间和资源共享的计算系统，如CTSS和Multics方面的贡献而获奖1991 Robin Milner因在可计算的函数逻辑(LCF)、ML和并行理论(CCS)这三个方面的贡献而获奖1992 Butler Lampson因在个人分布式计算机系统方面的贡献而获奖1993 Jurlis Hartmanis和Richard E. Stearns因奠定了计算复杂性理论的基础而获奖1994 Raj Reddy和Edward Feigenbaum因对大型人工智能系统的开拓性研究而获奖1995 Manuel Blum因奠定了计算复杂性理论的基础和在密码术及程序校验方面的贡献而获奖1996 Amir Pnueli因在中引入临时逻辑和对程序及系统检验的贡献而获奖1997 Douglas Engelbart因提出交互计算概念并创造出实现这一概念的重要技术而获奖1998 James Gray因在数据库和事务处理方面的突出贡献而获奖1999 Frederick P. Brooks, Jr. 由于在计算机体系架构、操作系统以及软件工程方面所做出的具有里程碑式意义的贡献。《人月神话》的作者2000 Andrew Chi-Chih Yao(姚期智) 由于在计算理论方面的贡献而获奖，包括伪随机数的生成算法、加密算法和通讯复杂性2001 Ole-Johan Dahl, Kristen Nygaard 由于面向对象编程始发于他们基础性的构想，这些构想集中体现在他们所设计的编程语言SIMULA I 和SIMULA 67中2002 Ronald L. Rivest, Adi Shamir, Leonard M. Adleman 由于在公共密钥理论和实践方面的基础性工作而获奖2003 Alan Kay 由于在面向对象语言方面原创性思想，领导了Smalltalk的开发团队，以及对PC的基础性贡献。至理名言：预测未来的最好方法是创造它2004 Vinton G. Cerf, Robert E. Kahn 由于在互联网方面开创性的工作，这包括设计和实现了互联网的基础通讯协议，TCP/IP，以及在网络方面卓越的领导2005 Naur Peter 因他在设计Algol 60语言于其定义的清晰性，Algol 60成为了许多现代程序设计语言的原型。在语法描述中广泛使用的BNF范式，其中的“N”便是来自Peter Naur的名字2006 Frances E. Allen因其在编译器优化理论和实践方面做出的开创性贡献而获奖。Allen是该奖项创立40年来的第一位女性得主。2007 Edmund M. Clarke，Allen Emerson和Joseph Sifakis因为“在将模型检查发展为被硬件和软件业中所广泛采纳的高效验证技术上的贡献”而荣获该奖2008 Barbara Liskov因在计算机软件更加可靠、安全和更具一致性方面的贡献而获奖。她也成为历史上第二位获得图灵奖的女性2009 Chuck Thacker以表彰他对第一台现代个人计算机——施乐帕克（Xerox PARC）Alto的先驱性设计，以及在局域网（包括以太网）、多处理器工作站、窥探高速缓存一致性协议和平板PC等方面的杰出成就与贡献。他是以太局域网的发明者之一，也是世界是第一台激光打印机发明者之一2010 Leslie G. Valiant因对众多的计算理论，包括PAC学习、枚举复杂性和代数计算和并行与分布式计算所做的变革性的贡献而获奖2011 Judea Pearl因在人工智能领域的基础性工作获奖，他提出的概率和因果性推理演算法，彻底改变了人工智能当初基于规则和推理的方向 3 分类3.1 硬件Maurice V. Wilkes (1967) ——第一台具有内部存储程序的计算机EDSACJohn Cocke (1987) —— RISC &amp; 编译优化Vinton Gray Cerf (2004) —— Internet基础通讯协议Chuck Thacke（2009）—— 局域网Frances E. Allen（2006）—— 编译器优化理论Edmund M. Clarke，Allen Emerson和Joseph Sifakis（2007）——模型验证 3.2 程序语言设计与实现Alan J. Perlis (1966) ——ALGOLJohn McCarthy (1971) —— LISPEdsger Wybe Dijkstra (1972) —— ALGOLJohn W. Backus (1977) —— FORTRANKenneth Eugene Iverson (1979) ——APL程序语言Niklaus Wirth (1984) —— PASCALJohn Cocke (1987) ——RISC &amp; 编译优化Ole-Johan Dahl，Kristen Nygaard (2001) —— Simula语言和面向对象概念 (获奖前30年)Alan Kay(2003) ——SmallTalk语言和面向对象程序设计Peter Naur(2005) —— ALGOL60以及编译设计Barbara Liskov(2008) ——数据抽象与分布式计算Edmund M. Clarke，Allen Emerson和Joseph Sifakis（2007）——模型验证 3.3 算法Richard Hamming (1968) —— 汉明码James Hardy Wilkinson (1970) —— 数值分析Donald E. Knuth —— art of computer programmingJohn E. Hopcroft，Robert Endre. Tarjan (1986) ——数据结构和算法设计William (Velvel) Morton Kahan (1989) —— 浮点运算IEEE标准主要设计师Andrew Chi-Chih Yao (姚期智) (2000) ——伪随机数复杂性，密码系统和通讯复杂性Ronald L. Rivest, Adi Shamir, Leonard M. Adleman(2002) ——公钥密码技术 3.4 自动机和可计算性Dana Stewart Scott (1976) —— 自动机Michael Oser Rabin (1976) ——自动机Stephen Arthur Cook (1982) —— NP完全性Richard Manning Karp (1985) —— 证明一个问题是否是属于NP完全Juris Hartmanis，Richard Edwin Stearns (1993) —— 计算复杂性Manuel Blum (1995) —— 计算复杂性，密码系统和程序检查验证Leslie G. Valiant（2010）——计算复杂性 3.5 人工智能Marvin Lee Minsky (1969) —— 神经元网络John McCarthy (1971) —— LISPAllen Newell，Herbert Simon (1975) —— Logic Theory MachineRaj Reddy，Edward Feigenbaum(1994) ——专家系统Leslie G. Valiant（2010）——机器学习Judea Pearl（2011）—— 概率和因果性推理演算法 3.6 操作系统Dennis MacAlistair Ritchie，Ken Thompson (1983) —— UNIXFernando Jose Corbato (1990) ——分时系统Frederick P. Brooks(1999) —— IBM System360 操作系统 3.7 数据库Charles W. Bachman (1973) —— 数据库Edgar Frank Codd (1981) ——关系数据模型James Gray(1998) —— 数据库和事务处理 3.8 图像处理和交互式系统Ivan Edward Sutherland (1988) ——图像处理，CADDouglas Engelbart(1998) —— 交互式系统，鼠标发明人 3.9 程序语言语义Dana Stewart Scott (1976) ——自动机Robert W. Floyd (1978) —— 编程语言语义，自动程序验证C. Antony R. Hoare (1980) —— Hoare Logic, CSPRobin Milner (1991) —— LCF，ML，CCS，PI-calculusAmir Pnueli (1996) —— 时序逻辑和系统验证]]></content>
      <categories>
        <category>致敬经典</category>
      </categories>
      <tags>
        <tag>致敬经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GEB]]></title>
    <url>%2F2019%2F01%2F30%2Fgeb-0%2F</url>
    <content type="text"><![CDATA[1 奇思妙想1.1 做事所花费的时间总是比你预期的要长，即使你的预期中考虑了侯世达定律。 1.2 人类认知世界过程就是人类在各学科构造形式系统并在其中推演定理解释世界的过程！ 1.3 自指和怪圈 1.4 大脑的结构 1.5 大脑的同构与形式系统的意义 1.6 一个同时存在于数理逻辑，分子生物学缠结层次系统 1.7 一个足够强有力的支撑系统 ，强到可以自我复制 1.8 跳出系统，超越自己也许是注定做不到的事情 1.9 不完全定理 1.10 画出来的说谎者悖论 1.11 音乐与怪圈 1.12 同构，螃蟹卡农 2 上篇GEB2.0 导言 一首音乐 逻辑的奉献 2.0.1 三部创意曲2.1 第一章 WU谜题2.1.1 二部创意曲2.2 第二章 数学中的意义与形式2.2.1 无伴奏阿基里斯奏鸣曲2.3 第三章 图形与衬底2.3.1 对位藏头诗2.4 第四章 一致性、完全性与几何学2.4.1 和声小迷宫2.5 第五章 递归结构与递归过程2.5.1 音程增值的卡农2.6 第六章 意义位于何处2.6.1 半音阶幻想曲，及互格2.7 第七章 命题演算2.7.1 螃蟹卡农2.8 第八章 印符数论2.8.1 一首无的奉献2.9 第九章 无门与哥德尔3 下篇EGB3.0 前奏曲3.1 第十章 描述的层次和计算机系统3.1.1 蚂蚁赋格3.2 第十一章 大脑和思维3.2.1 英、法、德、中组曲3.3 第十二章 心智和思维3.3.1 咏叹调及其种种变奏3.4 第十三章 BlooP和FlooP和GlooP3.4.1 G弦上的咏叹调3.5 第十四章 论TNT及有关系统中形式上不可判定的命题3.5.1 生日大合唱哇哇哇乌阿乌阿乌阿3.6 第十五章 跳出系统3.6.1 一位烟民富于启发性的思想3.7 第十六章 自指和自复制3.7.1 的确该赞美螃蟹3.8 第十七章 丘奇、图灵、塔斯基及别的人3.8.1 施德鲁，人设计的玩具3.9 第十八章 人工智能：回顾3.9.1 对实3.10 第十九章 人工智能：展望3.10.1 树懒卡农3.11 怪圈，或缠结的层次结构3.11.1 六部无插入赋格]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
</search>
